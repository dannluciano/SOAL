;; Statistical algorithms and utilities ;; ---------------------------------------------------------------------;; Distribution Stats;********************************************************************************************************;**** Funções especiais recursivas usadas para list-stats *****************************************;----------------------------------------------------------------------------------;Funções feitas por André para a função list-stats recursivo(defun primeiro-par-list-stats  (lista)	(if (= (length lista) 1)	  (list (list-min (first lista)))	  (cons (list-min (first lista))		(primeiro-par-list-stats  (rest lista)  ))))(defun segundo-par-list-stats  (lista)	(if (= (length lista) 1)	  (list (list-max (first lista)))	  (cons (list-max (first lista))		(segundo-par-list-stats  (rest lista)  ))))(defun terceiro-par-list-stats  (lista)	(if (= (length lista) 1)	  (list (g-round (media (first lista)) 2))	  (cons (g-round (media (first lista)) 2)		(terceiro-par-list-stats  (rest lista)  ))))(defun quarto-par-list-stats  (lista)	(if (= (length lista) 1)	  (list (vmode-sem-texto (first lista)))	  (cons (vmode-sem-texto (first lista))		(quarto-par-list-stats  (rest lista)  ))));;--------------------------------------------------------------------------------------------------;********************************************************************************************************;**** Funções especiais recursivas usadas para relative-list-stats *****************************************;----------------------------------------------------------------------------------;Funções feitas por André para a função relative-list-stats recursivo(defun primeiro-par-relative-list-stats  (list)	(if (= (length list) 1)	  (list (cond ((> (g-round (* (/ (list-min (first list)) 127) 1.0) 2) 1) 1)                (t (g-round (* (/ (list-min (first list)) 127) 1.0) 2))))	  (cons (cond ((> (g-round (* (/ (list-min (first list)) 127) 1.0) 2) 1) 1)                (t (g-round (* (/ (list-min (first list)) 127) 1.0) 2)))		(primeiro-par-relative-list-stats (rest list)  ))))(defun segundo-par-relative-list-stats (list)	(if (= (length list) 1)	  (list (cond ((> (g-round (* (/ (list-max (first list)) 127) 1.0) 2) 1) 1)                (t (g-round (* (/ (list-max (first list)) 127) 1.0) 2))))	  (cons (cond ((> (g-round (* (/ (list-max (first list)) 127) 1.0) 2) 1) 1)                (t (g-round (* (/ (list-max (first list)) 127) 1.0) 2)))		(segundo-par-relative-list-stats (rest list)  ))))(defun terceiro-par-relative-list-stats (list)	(if (= (length list) 1)	  (list (cond ((> (g-round (* (/ (media (first list)) 127) 1.0) 2) 1) 1)                (t (g-round (* (/ (media (first list)) 127) 1.0) 2))))	  (cons (cond ((> (g-round (* (/ (media (first list)) 127) 1.0) 2) 1) 1)                (t (g-round (* (/ (media (first list)) 127) 1.0) 2)))		(terceiro-par-relative-list-stats (rest list) ))))(defun quarto-par-relative-list-stats (list)	(if (= (length list) 1)	  (list (cond ((> (g-round (* (/ (vmode-sem-texto (first list)) 127) 1.0) 2) 1) 1)                (t (g-round (* (/ (vmode-sem-texto (first list)) 127) 1.0) 2))))	  (cons (cond ((> (g-round (* (/ (vmode-sem-texto (first list)) 127) 1.0) 2) 1) 1)                (t (g-round (* (/ (vmode-sem-texto (first list)) 127) 1.0) 2)))		(quarto-par-relative-list-stats (rest list)  ))));;--------------------------------------------------------------------------------------------------;********************************************************************************************************;**** Funções especiais recursivas usadas para sonic-quality-analysis *****************************************;----------------------------------------------------------------------------------(defun primeiro-par-sonic-quality-analysis (midicents velocities ped avarage rounding)        (if (= (length midicents) 1)	  (list (list (cond ((= avarage 1)                               (g-round (sum-q (first midicents) (first velocities) (media (first ped)) rounding) rounding))                             (t (g-round (sum-q (first midicents) (first velocities) (v-mode-piano (first ped)) rounding) rounding))) 	              (g-round (k-average (first midicents)) rounding)                      (g-round (q-gaps (first midicents)(first velocities)) rounding)	              (v-mode-piano (first velocities))))	  (cons (list (cond ((= avarage 1)                              (g-round (sum-q (first midicents) (first velocities) (media (first ped)) rounding) rounding))                            (t (g-round (sum-q (first midicents) (first velocities) (v-mode-piano (first ped)) rounding) rounding)))	              (g-round (k-average (first midicents)) rounding)	              (g-round (q-gaps (first midicents)(first velocities)) rounding)	              (v-mode-piano (first velocities)))                  (primeiro-par-sonic-quality-analysis (rest midicents) (rest velocities) (rest ped) avarage rounding))))(defun segundo-par-sonic-quality-analysis (midicents velocities rounding)	(if (= (length midicents) 1)	  (list (g-round-list (q-aux (first midicents) (first velocities)) rounding))	  (cons (g-round-list (q-aux (first midicents) (first velocities)) rounding)		(segundo-par-sonic-quality-analysis (rest midicents) (rest velocities) rounding))))		                                                          (defun terceiro-par-sonic-quality-analysis (midicents velocities ped avarage rounding)	(if (= (length midicents) 1)	  (list (cond ((= avarage 1)                     (g-round (sum-q (first midicents) (first velocities) (media (first ped)) rounding) rounding))                    (t (g-round (sum-q (first midicents) (first velocities) (v-mode-piano (first ped)) rounding) rounding))))	  (cons (cond ((= avarage 1)                     (g-round (sum-q (first midicents) (first velocities) (media (first ped)) rounding) rounding))                    (t (g-round (sum-q (first midicents) (first velocities) (v-mode-piano (first ped)) rounding) rounding)))		    (terceiro-par-sonic-quality-analysis (rest midicents) (rest velocities) (rest ped) avarage rounding))))(defun quarto-par-sonic-quality-analysis (midicents  rounding)	(if (= (length midicents) 1)	  (list (g-round-list (k (first midicents)) rounding))	  (cons (g-round-list (k (first midicents)) rounding)		(quarto-par-sonic-quality-analysis (rest midicents) rounding))))		                                                          		                                                          (defun quinto-par-sonic-quality-analysis (midicents  rounding)	(if (= (length midicents) 1)	  (list (g-round (k-average (first midicents)) rounding))	  (cons (g-round (k-average (first midicents)) rounding)		(quinto-par-sonic-quality-analysis (rest midicents) rounding))))		                                                          		                                                          (defun sexto-par-sonic-quality-analysis (midicents velocities rounding)	(if (= (length midicents) 1)	  (list (g-round (q-gaps (first midicents) (first velocities)) rounding))	  (cons (g-round (q-gaps (first midicents) (first velocities)) rounding)		(sexto-par-sonic-quality-analysis (rest midicents) (rest velocities) rounding))))(defun setimo-par-sonic-quality-analysis (velocities )	(if (= (length velocities) 1)	  (list (v-mode-piano (first velocities)))	  (cons (v-mode-piano (first velocities))		(setimo-par-sonic-quality-analysis (rest velocities))))) ;-----------------------------------------------------------------------------------(defun amb-rel (list range)  "Returns the percentage of the filling of a "range" (or "ambitus") entered by the user."  (g-round (* (/ (- (max-lista list) (min-lista list)) range) 1.0) 2));*******************************************************************************************;***********************  Versão Recursiva *************************************************;*******************************************************************************************(defun amb-rel-rec (list range)  "Returns the percentage of the filling of a 'range' (or 'soalambitus')entered by the user."  (if (= (length list) 1)  (list  (g-round (* (/ (- (max-lista (first list)) (min-lista (first list))) range) 1.0) 2))  (cons  (g-round (* (/ (- (max-lista (first list)) (min-lista (first list))) range) 1.0) 2)         (amb-rel-rec (rest list) range))));*******************************************************************************************(defun band-eval-3 (notas bandas)    "Fun‹o que diz se a banda est‡ ou n‹o ocupada. Bandas Ž no seguinte formato ((x0 y0) (x1 y1) ...). Permite bandas descontinuas."    (register-fill notas bandas));*******************************************************************************************;***********************  Versão Recursiva *************************************************;*******************************************************************************************(defun band-eval-3-rec (notas bandas)    "Fun‹o que diz se a banda est‡ ou n‹o ocupada. Bandas Ž no seguinte formato ((x0 y0) (x1 y1) ...).Permite bandas descontinuas."    (if (= (length notas) 1)    (list    (register-fill (first notas) bandas))    (cons (register-fill (first notas) bandas)          (band-eval-3-rec (rest notas) bandas))));*******************************************************************************************(defun band-eval-4 (notas bandas)    "Fun‹o que retorna a quantidade de notas em cada banda. Bandas Ž no seguinte formato ((x0 y0) (x1 y1) ...). Permite bandas descontinuas."    (register-fill-number notas bandas));*******************************************************************************************;***********************  Versão Recursiva *************************************************;*******************************************************************************************(defun band-eval-4-rec (notas bandas)    "Fun‹o que retorna a quantidade de notas em cada banda. Bandas Ž no seguinte formato ((x0 y0) (x1 y1) ...). Permite bandas descontinuas."    (if (= (length notas) 1)    (list    (register-fill-number (first notas) bandas))    (cons (register-fill-number (first notas) bandas)          (band-eval-4-rec (rest notas) bandas))));********************************************************************************************;********************************************************************************************************;**** Funções especiais recursivas usadas para notes-by-onsets *****************************************;---------------------------------------------------------------------------------- (defun primeiro-par-notes-by-onsets (midicents  onsets)               (if (= (length midicents) 1)             (list (notesByOnset (first midicents) (first onsets)))              (cons (notesByOnset (first midicents) (first onsets))                    (primeiro-par-notes-by-onsets (rest midicents) (rest onsets) ))))(defun segundo-par-notes-by-onsets (midicents  onsets f-length)               (if (= (length midicents) 1)             (list (notesByOnset-stats (first midicents) (first onsets) f-length))              (cons (notesByOnset-stats (first midicents) (first onsets) f-length)                   (segundo-par-notes-by-onsets (rest midicents) (rest onsets) f-length))))(defun terceiro-par-notes-by-onsets (midicents  onsets f-list-min)               (if (= (length midicents) 1)             (list (notesByOnset-stats (first midicents) (first onsets) f-list-min))              (cons (notesByOnset-stats (first midicents) (first onsets) f-list-min)                   (terceiro-par-notes-by-onsets (rest midicents) (rest onsets) f-list-min))))(defun quarto-par-notes-by-onsets (midicents  onsets f-list-max)               (if (= (length midicents) 1)             (list (notesByOnset-stats (first midicents) (first onsets) f-list-max))              (cons (notesByOnset-stats (first midicents) (first onsets) f-list-max)                   (quarto-par-notes-by-onsets (rest midicents) (rest onsets) f-list-max))))(defun quinto-par-notes-by-onsets (midicents  onsets f-media)               (if (= (length midicents) 1)             (list (notesByOnset-stats (first midicents) (first onsets) f-media))              (cons (notesByOnset-stats (first midicents) (first onsets) f-media)                   (quinto-par-notes-by-onsets (rest midicents) (rest onsets) f-media))))(defun sexto-par-notes-by-onsets (midicents  onsets f-vmode)               (if (= (length midicents) 1)             (list (notesByOnset-stats (first midicents) (first onsets) f-vmode))              (cons (notesByOnset-stats (first midicents) (first onsets) f-vmode)                   (sexto-par-notes-by-onsets (rest midicents) (rest onsets) f-vmode))));; ---------------------------------------------------------------------;;funcoes notes-by-onset;;-----------------------------------------------------------------------------(defun notesByOnset (midicents onsets)  "Agrupa na mesma lista cada onset e uma lista dos midicents que tem o correspondente onset.Ex.: ? (notes-by-onset '(1 2 3 4 5 6 7 8) '(10 10 14 10 12 18 14 18))     ? ((10 (1 2 4)) (12 (5)) (14 (3 7)) (18 (6 8)))"  (let ((onsets-sem-duplas (remove-duplicates onsets)))    (notesByOnset-aux onsets-sem-duplas midicents onsets)))(defun notesByOnset-aux (onsets-sem-duplas midicents onsets)  "Auxilia a funcao notesByOnset na recursao."      (cond ((null onsets-sem-duplas) nil)        ((= (length onsets) 1) (cons (list 0 (midicents-de-mesmo-onset (first onsets-sem-duplas) midicents onsets))                                      (notesByOnset-aux (rest onsets-sem-duplas) midicents onsets)))          (t (cons (list (first onsets-sem-duplas)                         (midicents-de-mesmo-onset (first onsets-sem-duplas) midicents onsets))                   (notesByOnset-aux (rest onsets-sem-duplas) midicents onsets)))))(defun midicents-de-mesmo-onset (onset midicents onsets)  "Retorna uma lista dos elementos da lista 'midicents' que possuem os 'onsets' correspondentes iguais a 'onset'."  (cond ((null midicents) nil)        (t (let ((onset-correspondente (elt onsets 0)))             (cond ((= onset-correspondente onset)                    (cons (first midicents)                          (midicents-de-mesmo-onset onset (rest midicents) (rest onsets))))                   (t (midicents-de-mesmo-onset onset (rest midicents) (rest onsets))))))))(defun notesByOnset-stats (midicents onsets funcao)  "Retorna uma lista com cada onset e o resultado da aplicacao da 'funcao' a lista das notas que possuem o mesmo onset."  (let ((notas-por-onset (notesByOnset midicents onsets)))    (notesByOnset-stats-aux notas-por-onset funcao)))(defun notesByOnset-stats-aux (notas-por-onset funcao)  "Auxilia a funcao notesByOnset-stats na recursao."  (cond ((null notas-por-onset) nil)        (t (cons (list (first (first notas-por-onset)) ;;o onset                       (list (if (or (equal funcao #'media) (equal funcao #'vmode-sem-texto))                          (g-round (first (mapcar funcao (list (second (first notas-por-onset))))) 2)                         (first (mapcar funcao (list (second (first notas-por-onset)))))))) ;;o minimo da lista das notas do onset                 (notesByOnset-stats-aux (rest notas-por-onset) funcao))))) ;; ---------------------------------------------------------------------;; ---------------------------------------------------------------------;; Cognitive dissonance(defvar *cognitive-disso-table*    '((100  1)      (200  0.85)      (300  0.6)      (400  0.33)      (500  0.15)      (600  0.68)      (700  0.08)      (800  0.5)      (900  0.42)      (1000 0.77)      (1100 0.94)      (1300 0.75)      (1400 0.57)      (1500 0.3)      (1600 0.16)      (1700 0.08)      (1800 0.34)      (2000 0.25)      (2100 0.21)      (2200 0.35)      (2300 0.63)      (2500 0.25)      (2600 0.29)      (3500 0.32)      (3700 0.25)) "Tabela de disson‰ncia cognitiva - Guigue 1996:229-238.")(defun cogdissrate (lista table)    "C‡lculo da taxa de disson‰ncia cognitiva. Recebe uma lista, cacula os intervalos entre os elementos e devolve os valores da taxa de dissonancia correspondente a cada intervalo. Classifica em ordem crescente a lista e retorna 0 se algum valor da lista naum existir na table"    (let* ((lista-aux (ordem-crescente lista))           (diferenca (x->dx lista-aux)))       (cond ((null diferenca) nil)            (t (cons (second (cond ((equal (assoc (first diferenca) table) nil) (list 0 0))                                   (t (assoc (first diferenca) table))))                     (cogdissrate (rest lista-aux) table))))));; ---------------------------------------------------------------------    ;; ---------------------------------------------------------------------;; Pitch dispersion(defun p-dispersion (midics range)    "Pitch dispersion. patch: testpitchdispersion."    (let ((soma-intervalos (reduce #'+ (lista-absoluta (diferenca-elementos-adjacentes midics))))	  (divisor (reduce #'+		     (lista-absoluta 			 (diferenca-elementos-adjacentes 			     (list (first midics) (first range) (second range) (first (last midics))))))))	(g-round (/ soma-intervalos divisor) 2)));; ---------------------------------------------------------------------;; ---------------------------------------------------------------------;; deviations(defun deviations (list &key (use-reference 1) (reference 0) (value 0))"Calcula o desvio absoluto. Caso o 'use-reference' for igual a 0, o 'reference' naum sera usado como valor de referencia, e sim o 'value'. Para maiores informacoes, vide a documentacao da biblioteca SOAL"    (let ((lista (if (equal (type-of (first list)) 'cons) (listadelistasdenumeros->listadenumeros list) list)))    (cond ((= use-reference 0) (deviations-aux (listadelistasdenumeros->listadenumeros list) value))        (t (deviations-aux lista (cond ((= reference 0) (media lista))                                      ((= reference 1) (first lista))                                      ((= reference 2) (first (ordem-crescente lista)))                                      ((= reference 3) (first (ordem-decrescente lista)))                                      (t (vmode-sem-texto lista))))))));*******************************************************************************************;**********************  Versão recursiva **************************************************;*******************************************************************************************(defun deviations-rec (list &key (use-reference 1) (reference 0) (value 0))"Calcula o desvio absoluto. Caso o 'use-reference' for igual a 0, o 'reference' naum sera usado como valor ;de referencia, e sim o 'value'. Para maiores informacoes, vide a documentacao da biblioteca SOAL"      (if (= (length list) 1)       (list       (cond ((= use-reference 0) (deviations-aux (first list) value))        (t (deviations-aux (first list) (cond ((= reference 0) (media (first list)))                                        ((= reference 1) (first (first list)))                                        ((= reference 2) (first (ordem-crescente (first list))))                                        ((= reference 3) (first (ordem-decrescente (first list))))                                        (t (vmode-sem-texto (first list))))))))       (cons (cond ((= use-reference 0) (deviations-aux (first list) value))        (t (deviations-aux (first list) (cond ((= reference 0) (media (first list)))                                        ((= reference 1) (first (first list)))                                        ((= reference 2) (first (ordem-crescente (first list))))                                        ((= reference 3) (first (ordem-decrescente (first list))))                                        (t (vmode-sem-texto (first list)))))))       (deviations-rec (rest list) :use-reference use-reference :reference reference :value value))));**********************************************************************************************;;alterada por Carol---> no lugar de g-round, coloquei g-round-list, tirei o retorno do variance(defun deviations-aux (lista numero)    "Os c‡lculos do patch deviations s‹o feitos aqui. Na fun‹o acima, deviations, Ž s— verificado qual Ž a entrada."    (let* ((variance            (if (= (length lista) 1)              0               (/ 		(reduce #'+ (mapcar #'square (subtracao-de-uma-lista-por-um-numero lista numero))) 		  (- (length lista) 1.0))))	   (std-deviation (sqrt variance)))        (g-round-list (list std-deviation) 2)));;funcao alterada por Ernesto (defun deviations-rel (list &key (use-reference 1) (reference 0) (value 0) (min 2100) (max 10800))  "Vide Relative Deviations no arquivo pwdg.htm."  (let* ((aux1 (deviations list :use-reference use-reference :reference reference :value value))         (aux2 (deviations (list (first list) min max (first (last list))) :use-reference use-reference :reference reference :value value))         (aux3 (g-round-list (mapcar #'/ aux1 aux2) 2)))    (deviations-rel-aux aux3)));*******************************************************************************************;**********************  2-Versão recursiva **************************************************;*******************************************************************************************(defun pitch-dev (midicents onsets &key (use-reference 1) (reference 0)                                              (value 0) (min 2100) (max 10800) escolha )     	(if (= (length (first onsets)) 1)		          0	            (let* ((f-list-min #'list-min)            (f-length #'length)            (f-list-max #'list-max)            (f-media #' media)            (f-vmode #'vmode-sem-texto)            (saida-notes-by-onsets (cond ((= escolha 0) (terceiro-par-notes-by-onsets midicents onsets f-media))                                       ((= escolha 1) (quarto-par-notes-by-onsets midicents onsets f-list-min))                                       ((= escolha 2) (quinto-par-notes-by-onsets midicents onsets f-list-max))                                       ((= escolha 3) (sexto-par-notes-by-onsets midicents onsets f-vmode))                                 (t (sexto-par-notes-by-onsets midicents onsets f-vmode)))))  (pitch-dev-aux saida-notes-by-onsets :use-reference use-reference :reference reference                                              :value value :min min :max max))))(defun  pitch-dev-aux (list &key use-reference  reference  value  min  max)     (let*  ((list-aux (second (mat-trans (first list)))))            (if (= (length list) 1)          (list (deviations-rel list-aux  :use-reference use-reference :reference reference                                              :value value :min min :max max))            (cons (deviations-rel list-aux  :use-reference use-reference :reference reference                                              :value value :min min :max max)              (pitch-dev-aux (rest list) :use-reference use-reference :reference reference                                              :value value :min min :max max)))))   ;*******************************************************************************************;**********************  Versão recursiva **************************************************;*******************************************************************************************(defun deviations-rel-rec (list &key (use-reference 1) (reference 0) (value 0) (min 2100) (max 10800))  "Vide Relative Deviations no arquivo pwdg.htm."  (let* ((aux1 (deviations ( first list) :use-reference use-reference :reference reference :value value))         (aux2 (deviations (list (first (first list)) min max (first (last (first list)))) :use-reference use-reference :reference reference :value value))         (aux3 (g-round-list (mapcar #'/ aux1 aux2) 2)))       (if (= (length list) 1)         (list	  (deviations-rel-aux aux3))         (cons (deviations-rel-aux aux3)               (deviations-rel-rec (rest list) :use-reference use-reference :reference reference                    :value value  :min min   :max max)))));*********************************************************************************************(defun deviations-rel-aux (lista)  "Fun‹o auxiliar que serve para verificar se existe alguma mŽdia acima de 1.0. Caso exista ela Ž arredondada  para 1."  (cond ((null lista) nil)  (t (cons (first lista) (deviations-rel-aux (rest lista))))));;alterada por Carol(defun deviation-list (lista1 lista2)    "Returns the 'divergence rate' between the relative standard deviation of two lists of same length. The algorithm first normalizes the lists, making them start from (0) as their lowest value. Then it builds a new list whose each element is the absolute distance between each pair of elements of the lists. Finally applies to this list the RELATIVE DEVIATIONS tool with (0) as the reference value and (0) and (x) as the minimal and maximal values, respectively.  x is the greatest element of the two input lists. "    (let ((aux (list (subtracao-de-uma-lista-por-um-numero lista1 (first (ordem-crescente lista1)))		     (subtracao-de-uma-lista-por-um-numero lista2 (first (ordem-crescente lista2))))))       (deviations-rel (lista-absoluta (flatten (mapcar #'diferenca-elementos-adjacentes (associador (first aux) (second aux)))))                       :use-reference 1		       :reference 0                       :min 0		       :max (first (ordem-decrescente (flatten aux))))));*******************************************************************************************;**********************  Versão recursiva **************************************************;*******************************************************************************************(defun deviation-list-rec (lista1 lista2)     "Returns the 'divergence rate' between the relative standard deviation of two lists of same length. The algorithmfirst normalizes the lists, making them start from (0) as their lowest value. Then it builds a new list whose each elementis the absolute distance between each pair of elements of the lists. Finally applies to this list the RELATIVE DEVIATIONStool with (0) as the reference value and (0) and (x) as the minimal and maximal values, respectively.  x is the greatestelement of the two input lists. "    (let ((aux (list (subtracao-de-uma-lista-por-um-numero (first lista1) (first (ordem-crescente (first lista1))))		     (subtracao-de-uma-lista-por-um-numero (first lista2) (first (ordem-crescente (first lista2)))))))         (if (= (length lista1) 1)       (list (deviations-rel (lista-absoluta (flatten (mapcar #'diferenca-elementos-adjacentes (associador (first aux) (second aux)))))                       :use-reference 1		       :reference 0                       :min 0		       :max (first (ordem-decrescente (flatten aux)))))	(cons (deviations-rel (lista-absoluta (flatten (mapcar #'diferenca-elementos-adjacentes (associador (first aux) (second aux)))))                       :use-reference 1		       :reference 0                       :min 0		       :max (first (ordem-decrescente (flatten aux))))	      (deviation-list-rec (rest lista1) (rest lista2))))));*******************************************************************************************(defun lists-deviation-aux (referencia coadjuvantes)    (cond ((null (first coadjuvantes)) nil)          (t (cons (first (deviation-list-rec (list referencia) (list (first coadjuvantes))))                   (lists-deviation-aux referencia (rest coadjuvantes))))));*******************************************************************************************(defun std-dev (lista)    "c‡lculo do desvio padr‹o."    (let* ((media-var (media lista))	   (aux1  (subtracao-de-uma-lista-por-um-numero lista media-var))	   (aux2  (reduce #'+ (mapcar #'* aux1 aux1)))	   (aux3  (- (length lista) 1)))       (g-round (sqrt (/ aux2 aux3)) 3)))(defun co-var (lista dev-std)    "??"    (let ((media-var (media lista))	  (dev-std-1 (* 100 dev-std)))      (g-round (/ dev-std-1 media-var) 2)));;---------------------------------------------------------------------;; ---------------------------------------------------------------------;; list functions(defun list-ref (lista)    "Indica a posi‹o da lista de um elemento."    (let ((listas-prontas (list (spliter (length lista) 1) lista)))	(associador (first listas-prontas) (second listas-prontas))));modificada por Carol(defun list-wght (lista)    "Fun‹o que retorna a quantidade de cada elemento da lista."   (sort (contador lista) '> :key 'second));*******************************************************************************************;**********************  Versão recursiva **************************************************;*******************************************************************************************(defun list-wght-rec (lista)    "Fun‹o que retorna a quantidade de cada elemento da lista."  (if (= (length lista) 1)     (list     (sort (contador (first lista)) '> :key 'second))     (cons (sort (contador (first lista)) '> :key 'second)             (list-wght-rec (rest lista)))));******************************************************************************************;modificada por Carol(defun listindex (lista)     "Retorna uma lista onde cada elemento Ž um par <x y> onde y eh um elemento de lista e x Ž o index de y - iniciando em 0."    (let ((aux-index nil))	(do ((aux 1 (+ aux 1)))	((= aux (+ (length lista) 1)))	(setf aux-index (cons (list (- aux 1) (elt lista (- aux 1))) aux-index)))       (reverse aux-index)));*******************************************************************************************;**********************  Versão recursiva **************************************************;*******************************************************************************************(defun listindex-rec (lista)    "Retorna uma lista onde cada elemento Ž um par <x y> onde y eh um elemento de lista e x Ž o index de y - iniciando em 0."    (let ((aux-index nil))	(do ((aux 1 (+ aux 1)))	((= aux (+ (length (first lista)) 1)))	(setf aux-index (cons (list (- aux 1) (elt (first lista) (- aux 1))) aux-index)))      (if (= (length lista) 1)       (list (reverse aux-index))       (cons (reverse aux-index)             (listindex-rec (rest lista))))));********************************************************************************************;modificada por Carol(defun lst-max (lista &key (use-normal 1))    "Vide patch list-max aberto in OOA-ALL-LIBS-LOWLVL."    (let* ((lista-indexada-em-reverse (listindex lista))	   (lista-indexada-normal (reverse lista-indexada-em-reverse)))       (if (= use-normal 1)	   (lst-max-aux lista-indexada-normal)	   (lst-max-aux lista-indexada-em-reverse))))(defun lst-max-aux (lista)    "As contas s‹o feitas aqui."    (let ((index-desfeito (associador (first lista) (second lista))))	(list (elt (first index-desfeito)	           (position (max-lista (second index-desfeito)) (second index-desfeito) :from-end t))	      (max-lista (second index-desfeito)))))(defun vmode (sequencia)    "Patch v-mode-meu.pw."    (let* ((entrada-contada (contador (ordem-crescente sequencia)))	   (primeiros '((69 3)))	   (segundos  (mapcar #'second entrada-contada))	   (media-entrada (media sequencia))	   (segundos-multiplicados (reduce #'* segundos))	   (posicao (elt primeiros (position (first (ordem-decrescente segundos)) segundos :from-end t))))       (if (= segundos-multiplicados 1)	   (list (* media-entrada 1.0) 'average 'value '- 'no 'mode 'in 'this 'list)	   posicao)))(defun vmode-sem-texto (sequencia)    "A mesma fun‹o anterior, mas sem o texto que indica que Ž uma mŽdia."    (if (null sequencia) nil    (let* ((entrada-contada (contador (ordem-crescente sequencia)))	   (primeiros (mapcar #'first entrada-contada))	   (segundos  (mapcar #'second entrada-contada))	   (media-entrada (media sequencia))	   (segundos-multiplicados (reduce #'* segundos))	   (posicao (elt primeiros (position (first (ordem-decrescente segundos)) segundos :from-end t))))       (if (= segundos-multiplicados 1)	   (* media-entrada 1.0)	   posicao))))(defun moda-lista-de-listas (lista)  (if (= (length lista) 1)      (list (vmode-sem-texto (first lista)))    (cons (vmode-sem-texto (first lista))          (moda-lista-de-listas (rest lista)))))(defun vmode-sem-texto-zeroparaumunicoelemento (sequencia)   "A mesma que a anterior, mas se a lista tiver apenas um elemento, o retorno da funcao e zero"  (if (= (length sequencia ) 1)     0.0    (v-mode-sem-texto sequencia)))(defun keep-dups (lista)  "Retorna uma lista com os elementos que se repetem na lista list."  (cond ((null lista) nil)         ((> (count (first lista) lista) 1)          (append (list (list (list (first lista)) (list (count (first lista) lista))))   ; retornar elem da lista e o num de repet.ex: (50 50 50 20 30 30) -> ((50) (3)) max 08/05/2006                (keep-dups (remove (first lista) lista))))   ;modif max. chama keep-dups 26/04/2006        (t (keep-dups (remove (first lista) lista))))) ;funcaos recursiva. max 26/04/2006(defun keep-dups-rec (list-of-lists)  "Retorna uma lista com os elementos que se repetem na lista list."     (if (= (length list-of-lists) 1)         (list (keep-dups (first list-of-lists)))         (cons (keep-dups (first list-of-lists))               (keep-dups-rec (rest list-of-lists)))));;criada por Luana e Carol;(defun keep-dups (list);  "Retorna uma lista com os elementos que se repetem na lista list.";  (cond ((null list) nil) ;        ((> (count (first list) list) 1) ;         (append (list (build-list (first list) (count (first list) list))) ;               (keep-duplicates (remove (first list) list))));        (t (keep-duplicates (remove (first list) list)))));;----------------------------------------------------------------------;;   FUNCAO FIND-ELEMENTS;;----------------------------------------------------------------------;;Ainda nao tah funcionando quando existem elementos repetidos(defun find-elemts (elements list-of-lists)  "Para Didier documentar. Achar (5 7) em ((1 2 3 4) (5 7) (3 4 5) (1 4) (6 7) (4 5 5 7 8))resultado: (((5 7) 1) ((5) 2) ((7) 4) ((5 5 7) 5))"    (let* ((tamanho (length list-of-lists))         (lista-de-posicoes (list-of-positions (+ tamanho 1) 1)) ;tam por 1 preenche uma lista a partir de um valor inicial(list-of-position)         (lista-de-listas-com-posicoes (insert-position lista-de-posicoes list-of-lists)); insere os valores da primeira lista nas ultimas posicoes das listas na seg entrada         (lista (find-elements-positions elements lista-de-listas-com-posicoes)))        (junta-elementos0  lista lista-de-posicoes)));******************************************************************************************;funcoes criadas por Hildegard para serem uteis para find-elements;dada uma lista simples e um numero normal, retorna as posicoes em que esse numero ocorre na lista. (defun achaindice (element list indice)      (cond ((null list) nil)            ((= element (first list))              (if (unit-list list)               (list indice)               (cons indice (achaindice element (rest list) (+ indice 1)))))             (t (achaindice element (rest list) (+ indice 1)))));dada uma lista de elementos a procurar e uma lista simples onde eles serao procurados, retorna as posicoes de cada elemento procurado nessa lista(defun posicoesparacadaelemento (listadeprocurados listavarrida)      (cond ((null listadeprocurados) nil)            (t (setq result-achaindice (achaindice (first listadeprocurados) listavarrida 0))               (if (null result-achaindice)                 (posicoesparacadaelemento (rest listadeprocurados) listavarrida)                 (cons (cons (list (first listadeprocurados)) result-achaindice)                       (posicoesparacadaelemento (rest listadeprocurados) listavarrida))))))(defun resultadofindelements (listadeprocurados listadelistas)    (cond ((or (null listadeprocurados) (null listadelistas)) nil)          (t (setq resultado (posicoesparacadaelemento listadeprocurados (first listadelistas)))             (if (null resultado)                (cons (list nil) (resultadofindelements listadeprocurados (rest listadelistas)))               (cons resultado (resultadofindelements listadeprocurados (rest listadelistas)))))))   ;******************************************************************************************;;passar a lista jah com a posicao como ultimo elemento(defun find-the-element (element list-with-position)  "Returns the last element of list(position) if element belongs to list-with-position."  (cond  ((unit-list list-with-position) nil)         (t (cond ((equal element (first list-with-position))                    (first (last list-with-position)))                                                 (t (find-the-element element (rest list-with-position)))))));;funciona em conjunto;;---------------------------------------------------------(defun find-elements-positions (elements list-of-lists-with-positions)  ""  (cond ((not (atom elements)) ;;if elements is a list         (cons (find-elements-positions (first elements) list-of-lists-with-positions)               (find-elements-positions (rest elements) list-of-lists-with-positions)))        ((null elements) nil)        (t (find-elements-positions-aux elements list-of-lists-with-positions)))) (defun find-elements-positions-aux (elements list-of-lists-with-positions)  ""  (cond ((null list-of-lists-with-positions) nil)        (t (cons (list (list elements) (find-the-element elements (first list-of-lists-with-positions)))	         (find-elements-positions-aux elements (rest list-of-lists-with-positions))))));;---------------------------------------------------------;;a lista eh cada sublista da lista de junta-elementos (referente a cada numero buscado)(defun achou-valor (lista valor)  ""  (cond ((null lista) nil)         ((equal (first (last (first lista))) valor)          (first (first (first lista))))        (t (achou-valor (rest lista) valor))));;--------------------------------------------------------;;a lista passada aqui eh a retornada por find-elements;;lista-de-posicoes passada eh a list-of-positions(defun junta-elementos0 (lista lista-de-posicoes)  ""  (cond ((null lista-de-posicoes) nil)	(t (cond ((not (equal (junta-elementos lista (first lista-de-posicoes)) nil))                  (cons (list (junta-elementos lista (first lista-de-posicoes)) (first lista-de-posicoes))			(junta-elementos0 lista (rest lista-de-posicoes))))                 (t (junta-elementos0 lista (rest lista-de-posicoes)))))));;a lista passada aqui eh a retornada por find-elements(defun junta-elementos (lista valor)  ""  (cond ((null lista) nil)        (t (cond ((not (equal (achou-valor (first lista) valor) nil))                   (cons (achou-valor (first lista) valor)		        (junta-elementos (rest lista) valor)))                 (t (junta-elementos (rest lista) valor))))))     ;;----------------------------------------------------------------------;;   FIM DA FUNCAO FIND-ELEMENTS;;----------------------------------------------------------------------    ;;----------------------------------------------------------------------(defun ppi (onsets durs)  ; esta fun‹o Ž a ppi da biblioteca - na tese est‡ na p‡gina 500    "Esta fun‹o vai ser a **Smaller Impulse**.     Retorna o menor valor da lista que contem as diferencas entre os elementos adjacentes da lista "onsets"     (sem os elementos repetidos) e os elementos da lista "durs". "    (let* ((onsets-sem-duplas (remove-duplicates onsets)))	(first	    (ordem-crescente		(append 		    (lista-absoluta (g-round-list (diferenca-elementos-adjacentes onsets-sem-duplas) 4)) 		    durs)))));*******************************************************************************************;***********************  Versão Recursiva *************************************************;*******************************************************************************************(defun ppi-rec (onsets durs)  ; esta fun‹o Ž a ppi da biblioteca - na tese est‡ na p‡gina 500    "Esta fun‹o vai ser a **Smaller Impulse**.     Retorna o menor valor da lista que contem as diferencas entre os elementos adjacentes da lista "onsets"     (sem os elementos repetidos) e os elementos da lista "durs". "    (let* ((onsets-sem-duplas (remove-duplicates (first onsets))))    (if (= (length onsets) 1)      (list	(first	    (ordem-crescente             (g-round-list              (append		    (lista-absoluta  (diferenca-elementos-adjacentes onsets-sem-duplas)) 		    (first durs)) 4))))      (cons	   (first	    (ordem-crescente		(g-round-list                 (append		    (lista-absoluta (diferenca-elementos-adjacentes onsets-sem-duplas))		    (first durs)) 4)))          (ppi-rec (rest onsets) (rest durs))))));*********************************************************************************************(defun densidade (lista step)    "Fun‹o que calcula a density rate."    (g-round	(* 	    (/		(length (remove-duplicates lista))		(/ (+ (ambitus lista) step) step))	    1.0)	2));*******************************************************************************************;***********************  Versão Recursiva *************************************************;*******************************************************************************************(defun densidade-rec (lista &key step (remove-dups 1))    "Fun‹o que calcula a density rate."     (let ((lista-aux  (cond ((= remove-dups 0) (first lista))                   (t (remove-duplicates (first lista))))))      (if (= (length lista) 1)      (list      (g-round	 (*	      (/	       	 (length (remove-duplicates lista-aux))		 (/ (+ (soalambitus lista-aux) step) step))	     1.0)	 2))       (cons (g-round	 (*	      (/	       	 (length (remove-duplicates lista-aux))		 (/ (+ (soalambitus lista-aux) step) step))	     1.0)	 2)	   (densidade-rec (rest lista) :step step  :remove-dups remove-dups  )))));*****************************************************************************************(defun densidade-abs-rec (lista &key step (remove-dups 1))  "Funcao que retorna o densidade absoluta (o tamanho da lista)."  (let ((lista-aux  (cond ((= remove-dups 0) (first lista))                   (t (remove-duplicates (first lista))))))      (if (= (length lista) 1)      (list (length lista-aux))      (cons (length lista-aux)		 	    (densidade-abs-rec (rest lista) :step step  :remove-dups remove-dups  )))));*****************************************************************************************(defun primeiro-par-velocity-rate (velocity &key velo-parag (average 1) (rounding 2))      (if (= (length velocity) 1)       (list (cond ((= (length (first velocity)) 1) (g-round (/ (first (first velocity)) velo-parag) 2))                    ((= average 1) (g-round (/ (vmode-sem-texto (first velocity)) velo-parag) rounding))                  (t (g-round (/(media (first velocity)) velo-parag) rounding))))                 (cons (cond((= average 1) (g-round (/ (vmode-sem-texto (first velocity)) velo-parag) rounding))                    (t (g-round(/ (media (first velocity)) velo-parag) rounding)))              (primeiro-par-velocity-rate (rest velocity) :velo-parag velo-parag                                               :average average :rounding rounding))))(defun segundo-par-velocity-rate (velocity &key (average 1) (rounding 2))      (if (=(length velocity) 1)       (list (if (= average 1)               (vmode-sem-texto (first velocity))               (g-round (media (first velocity)) rounding)))              (cons (if (= average 1)               (vmode-sem-texto (first velocity))               (g-round (media (first velocity)) rounding))              (segundo-par-velocity-rate (rest velocity)  :average average))));; ---------------------------------------------------------------------;; --------------------------------------------------------------------- ; Taux et taux elements(defun contador-em-duas-listas (lista1 lista2)    "Conta cada elemento de lista1 em lista2."    (cond ((null lista1) nil)	  (t (cons (count (first lista1) lista2)		   (contador-em-duas-listas (rest lista1) lista2)))))(defun taux-elements (elmts? list note?)     "Doc."     (let* ((nomes-notas (midicents->notes elmts? "C4"))             (tamanho-lista (length list))	    (elms-contados (contador-em-duas-listas elmts? list))	    (lista-notas-numeros (list elmts?      (taux elms-contados tamanho-lista 100.0 2)))	    (lista-notas-letras  (list nomes-notas (taux elms-contados tamanho-lista 100.0 2))))       (if (= note? 0)         (associador (first lista-notas-numeros) (second lista-notas-numeros))         (associador (first lista-notas-letras)  (second lista-notas-letras)))));*******************************************************************************************;***********************  Versão Recursiva *************************************************;*******************************************************************************************(defun taux-elements-rec (elmts? list note?)     "Doc."     (let* ((nomes-notas (midicents->notes elmts? "C4"))            (tamanho-lista (length (first list)))	    (elms-contados (contador-em-duas-listas elmts? (first list)))	    (lista-notas-numeros ( list  elmts? (taux elms-contados tamanho-lista 100.0 2)))	    (lista-notas-letras  (list nomes-notas (taux elms-contados tamanho-lista 100.0 2))))      (if (= (length list) 1)       (list       (if (= note? 0)         (associador (first lista-notas-numeros) (second lista-notas-numeros))         (associador (first lista-notas-letras)  (second lista-notas-letras))))	(cons  (if (= note? 0)         (associador (first lista-notas-numeros) (second lista-notas-numeros))         (associador (first lista-notas-letras)  (second lista-notas-letras)))         (taux-elements-rec elmts? (rest list) note?)))));********************************************************************************************;alterada por Luana e Carol(defun taux (val max base decimal)    "Calcula o rate. Multiplica o val pela base e depois divide o resultado por max. Val e Max podem ser numero ou lista.Se ambos forem listas, tem que ter o mesmo tamanho."    (if (numberp val) ; quando val for um numero e max um numero.      (if (numberp max) ; quando val for um numero e max uma lista.        (g-round (/ (* val base) max) decimal)        (g-round-list (divisao-de-um-numero-por-uma-lista (* val base) max) decimal))      (if (numberp max) ; quando max for um numero e val uma lista        (g-round-list (divisao-de-uma-lista-por-um-numero (multiplicacao-de-uma-lista-por-um-numero val base) max) decimal)        (g-round-list (mapcar #'/ (multiplicacao-de-uma-lista-por-um-numero val base) max) decimal)))) ; quando ambos forem listas (de mesmo tamanho);*******************************************************************************************;***********************  Versão Recursiva *************************************************;*******************************************************************************************(defun taux-rec (val max base decimal)    "Calcula o rate. Multiplica o val pela base e depois divide o resultado por max. Val e Max podem ser numero ou lista.Se ambos forem listas, tem que ter o mesmo tamanho."  (if (= (length val) 1)    (list (if (numberp (first val)) ; quando val for um numero e max um numero.      (if (numberp max) ; quando val for um numero e max uma lista.        (g-round (/ (* (first val) base) max) decimal)        (g-round-list (divisao-de-um-numero-por-uma-lista (* (first val) base) max) decimal))      (if (numberp max) ; quando max for um numero e val uma lista        (g-round-list (divisao-de-uma-lista-por-um-numero (multiplicacao-de-uma-lista-por-um-numero (first val) base) max) decimal)        (g-round-list (mapcar #'/ (multiplicacao-de-uma-lista-por-um-numero (first val) base) max) decimal)))) ; quando ambos forem listas (de mesmo tamanho)    (cons (if (numberp (first val)) ; quando val for um numero e max um numero.      (if (numberp max) ; quando val for um numero e max uma lista.        (g-round (/ (* (first val) base) max) decimal)        (g-round-list (divisao-de-um-numero-por-uma-lista (* (first val) base) max) decimal))      (if (numberp max) ; quando max for um numero e val uma lista        (g-round-list (divisao-de-uma-lista-por-um-numero (multiplicacao-de-uma-lista-por-um-numero (first val) base) max) decimal)        (g-round-list (mapcar #'/ (multiplicacao-de-uma-lista-por-um-numero (first val) base) max) decimal))) ; quando ambos forem listas (de mesmo tamanho)      (taux-rec (rest val) max base decimal))));**********************************************************************************************;; ---------------------------------------------------------------------;-------------;mc->n;-------------;feita por Luana e Carol;;com string, com reference ("C3" ou "C4") e com opcao de lista como argumento(defun midicents->notes (midicents reference)  "Takes a midi-cent value <midicents> or list of midi-cent values, and returns corresponding symbolic (ASCII) note names. Symbolic note names follow standard notation with middle c (midi-cent 6000) being "C3".  Semitones are labeled with a '#'.Quartertone flats are labeled with a '_', and quartertone sharps with a '+'.  Thus, C3 a quartertone sharp (midi-cent 6050),would be labeled "C+3".  Gradations smaller than a quartertone are expressed as the closest  quartertone + or - the remaining cent value (i.e., midi-cent 5376 would be expressed as "F#2-2  (cond ((not (atom midicents)) ;;if midicents is a list         (cons (midicents->notes (first midicents) reference)               (midicents->notes (rest midicents) reference)))        ((equal midicents nil) nil)        (t (let* ((midicents-aux (cond ((or (equal reference "C3") (equal reference "c3")) midicents)                                       (t (+ midicents 1200))))                  (aux (truncate (/ midicents-aux 1200)))                  (oitava (- aux 2))                  (modulo (mod midicents-aux 1200))                  (nota (cond ((and (>= modulo 0) (<= modulo 25)) 'C)                              ((and (> modulo 25) (<= modulo 75)) 'C+)                              ((and (> modulo 75) (<= modulo 125)) 'C#)                              ((and (> modulo 125) (<= modulo 175)) 'D_)                              ((and (> modulo 175) (<= modulo 225)) 'D)                              ((and (> modulo 225) (<= modulo 275)) 'D+)                              ((and (> modulo 275) (<= modulo 325)) 'D#)                              ((and (> modulo 325) (<= modulo 375)) 'E_)                              ((and (> modulo 375) (<= modulo 425)) 'E)                              ((and (> modulo 425) (<= modulo 475)) 'E+)                              ((and (> modulo 475) (<= modulo 525)) 'F)                              ((and (> modulo 525) (<= modulo 575)) 'F+)                              ((and (> modulo 575) (<= modulo 625)) 'F#)                              ((and (> modulo 625) (<= modulo 675)) 'G_)                              ((and (> modulo 675) (<= modulo 725)) 'G)                              ((and (> modulo 725) (<= modulo 775)) 'G+)                              ((and (> modulo 775) (<= modulo 825)) 'G#)                              ((and (> modulo 825) (<= modulo 875)) 'A_)                              ((and (> modulo 875) (<= modulo 925)) 'A)                              ((and (> modulo 925) (<= modulo 975)) 'A+)                              ((and (> modulo 975) (<= modulo 1025)) 'A#)                              ((and (> modulo 1025) (<= modulo 1075)) 'B_)                              ((and (> modulo 1075) (<= modulo 1125)) 'B)                              ((and (> modulo 1125) (< modulo 1200)) 'B+)))                  (complemento (cond ((and (> modulo 0) (< modulo 50))                                       (cond ((<= (- midicents-aux (+ 3600 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 3600 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 3600 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 50) (< modulo 100))                                       (cond ((<= (- midicents-aux (+ 3650 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 3650 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 3650 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 100) (< modulo 150))                                        (cond ((<= (- midicents-aux (+ 3700 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 3700 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 3700 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 150) (< modulo 200))                                       (cond ((<= (- midicents-aux (+ 3750 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 3750 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 3750 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 200) (< modulo 250))                                       (cond ((<= (- midicents-aux (+ 3800 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 3800 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 3800 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 250) (< modulo 300))                                       (cond ((<= (- midicents-aux (+ 3850 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 3850 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 3850 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 300) (< modulo 350))                                       (cond ((<= (- midicents-aux (+ 3900 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 3900 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 3900 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 350) (< modulo 400))                                       (cond ((<= (- midicents-aux (+ 3950 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 3950 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 3950 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 400) (< modulo 450))                                       (cond ((<= (- midicents-aux (+ 4000 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 4000 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 4000 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 450) (< modulo 500))                                       (cond ((<= (- midicents-aux (+ 4050 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 4050 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 4050 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 500) (< modulo 550))                                       (cond ((<= (- midicents-aux (+ 4100 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 4100 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 4100 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 550) (< modulo 600))                                       (cond ((<= (- midicents-aux (+ 4150 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 4150 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 4150 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 600) (< modulo 650))                                       (cond ((<= (- midicents-aux (+ 4200 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 4200 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 4200 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 650) (< modulo 700))                                       (cond ((<= (- midicents-aux (+ 4250 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 4250 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 4250 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 700) (< modulo 750))                                       (cond ((<= (- midicents-aux (+ 4300 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 4300 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 4300 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 750) (< modulo 800))                                       (cond ((<= (- midicents-aux (+ 4350 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 4350 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 4350 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 800) (< modulo 850))                                       (cond ((<= (- midicents-aux (+ 4400 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 4400 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 4400 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 850) (< modulo 900))                                       (cond ((<= (- midicents-aux (+ 4450 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 4450 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 4450 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 900) (< modulo 950))                                       (cond ((<= (- midicents-aux (+ 4500 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 4500 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 4500 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 950) (< modulo 1000))                                       (cond ((<= (- midicents-aux (+ 4550 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 4550 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 4550 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 1000) (< modulo 1050))                                       (cond ((<= (- midicents-aux (+ 4600 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 4600 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 4600 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 1050) (< modulo 1100))                                       (cond ((<= (- midicents-aux (+ 4650 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 4650 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 4650 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 1100) (< modulo 1150))                                       (cond ((<= (- midicents-aux (+ 4700 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 4700 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 4700 (* 1200 (- oitava 1))) 50) midicents-aux))))))                                     ((and (> modulo 1150) (< modulo 1200))                                       (cond ((<= (- midicents-aux (+ 4750 (* 1200 (- oitava 1)))) 25)                                              (concatenate 'string (string '+) (prin1-to-string (- midicents-aux (+ 4750 (* 1200 (- oitava 1)))))))                                            (t (concatenate 'string (string '-) (prin1-to-string (- (+ (+ 4750 (* 1200 (- oitava 1))) 50) midicents-aux)))))))))             (concatenate 'string (string nota) (prin1-to-string oitava) complemento)))));*******************************************************************************************;***********************  Versão Recursiva *************************************************;*******************************************************************************************(defun midicents->notes-rec (midicents reference)    (if (= (length midicents) 1)    (list (midicents->notes (first midicents) reference))    (cons (midicents->notes (first midicents) reference)            (midicents->notes-rec (rest midicents) reference))));******************************************************************************************;-------------;mcs->pcs;-------------;feita por Carol(defun midicents->pitch-classes (midicents)  "Converts midicents into pitch-classes (C = 0). "  (second (multiple-value-list (om// (divisao-de-uma-lista-por-um-numero midicents 100) 12))));*******************************************************************************************;***********************  Versão Recursiva *************************************************;*******************************************************************************************(defun midicents->pitch-classes-rec (midicents)  "Converts midicents into pitch-classes (C = 0). "  (if (= (length midicents) 1)  (list  (second (multiple-value-list (om// (divisao-de-uma-lista-por-um-numero (first midicents) 100) 12))))  (cons (second (multiple-value-list (om// (divisao-de-uma-lista-por-um-numero (first midicents) 100) 12)))        (midicents->pitch-classes-rec (rest midicents)))));******************************************************************************************(defun calcula-entropia (lista)  (if (= (length lista) 1)      (list (- (somatorio (calcula-entropia-lista-simples (first lista)))))    (cons (somatorio (calcula-entropia-lista-simples (first lista)))          (calcula-entropia (rest lista)))))(defun calcula-entropia-lista-simples (lista)  (if (= (length lista) 1)      (list (calcula-entropia-numero (first lista)))    (cons (calcula-entropia-numero (first lista))          (calcula-entropia-lista-simples (rest lista)))))(defun calcula-entropia-numero (numero)  (if (= numero 0)      0  (* numero (om-log numero 2))))